----------------
-- Defines the polynomial ideal of critical configurations.
--
-- This ideal is for n points on the sphere S^2.
--
-- The ideal is generated by polynomials with variables:
-- -- wik, i=0,...,n-1, k=0,1,2 (cartesian coordinates of points in R^3), and
-- -- zij, i<j (auxiliary variables).
--
-- The generators are the polynomials corresponding to the following equations:
-- -- Definition of auxiliary variables zij that guarantee wi != wj.
-- -- Null gradient of the problem Lagrangian.
--
-- Execute from command line using: M2 fileName.m2
--
-- 01/26 - MVD.
----------------

fixDipole = false; -- fix a dipole between the last two points.

saveIdeal = true; -- save ideal with msolve format.

n = 7; -- number of points (n>=3)

p = 0; -- p=0 => rational coefficients, p>0 => coefficients in Zp, p prime.

-- show parameters
<< endl << "Number of points: " << n << endl;
<< endl << "Coefficients in Zp, with p=" << p << endl;

<< endl << "Fix dipole: " << fixDipole << endl;
<< endl << "Save ideal with msolve format: " << saveIdeal << endl;

--------------------------------
-- Polynomial coefficients.
--------------------------------
if ( p == 0 ) then (
	kk = QQ; -- rational coefficients
) else ( -- p>0, p prime
	kk = ZZ/p; -- integers modulo p
)

--------------------------------
-- Create variables of polynomial ring.
--
-- flatten converts matrix to row vector, concatenating columns.
--------------------------------

-- w_ik, i=0,...,n-1, k=0,1,2.
Wvars = flatten apply(n, i -> flatten apply( 3, k -> w_(i,k) ) )

-- Z_ij, for 0 <= i < j <= n-1
-- i=0,...,j-1, j=0,...,n-1
Zvars = flatten apply(n, j -> flatten apply( j, i -> z_(i,j) ) )

----------------------------
-- Create polynomial ring.
----------------------------
R = kk[Zvars, Wvars, MonomialOrder => GRevLex];

-- describe R


----------------------
-- Equations that define the auxiliary variables zij.
-- zij * ( 1 - w_i^T * w_j) - 1 = 0, for 0 <= i < j <= n-1.
-- Implies w_i != w_j
----------------------
I1 = ideal(R); -- null ideal
for j from 0 to n-1 do (
  for i from 0 to j-1 do ( -- i<j
    eqAux = z_(i,j) * ( 1 -  ( w_(i,0) * w_(j,0) + w_(i,1) * w_(j,1) + w_(i,2) * w_(j,2) ) ) - 1;

    I1 = I1 + ideal(eqAux); -- add equation to ideal
  );
);

-- << endl << "Auxiliary variables zij: " << endl << describe I1


----------------------
-- Points on the surface of the unit sphere: w_i^T * w_i = 1, for i = 0,..,n-1.
----------------------
I2 = ideal(R); -- null ideal

for i from 0 to n-1 do (
  I2 = I2 + ideal( w_(i,0)^2 + w_(i,1)^2 + w_(i,2)^2 - 1 );
);


------------------------------
-- Matrix nxn symmetric with variables Z_ij and zeros on its diagonal.
-- Simplifies the definition of the rest of the equations.
------------------------------
Z = mutableMatrix id_(R^n) -- mutable identity matrix nxn

for j from 0 to n-1 do (
  Z_(j,j) = 0; -- null diagonal

  for i from 0 to j-1 do (
    Z_(i,j) = z_(i,j);
    Z_(j,i) = z_(i,j); -- symmetric
  )
)

Z = matrix Z -- stops being mutable (modifiable)

------------------------------
-- Equations of null gradient of Lagrangian.
-- One scalar equation for each coordinate of each point w_i.
------------------------------
I3 = ideal(R); -- null ideal

d = 3; -- points in R^d.
for i from 0 to n-1 do ( -- each point wi
  for k from 0 to d-1 do ( -- each coordinate of wi
    eqAux = -(n-1) * w_(i,k);

    -- sum in j!=i
    eqAux += sum apply( n, j -> ( w_(i,k) - w_(j,k) ) * Z_(i,j) );

    I3 = I3 + ideal(eqAux); -- add equation to ideal
  );
);


--------------------
-- Sum of ideals.
--------------------
J = I1 + I2 + I3 -- all the equations

----------------
-- Remove orthogonal symmetries by fixing coordinates.
-- It also removes the fixed variables from the ring.
----------------

if fixDipole then ( -- fix a dipole between the last two points.
  ----------------
  -- Fix: w_(n-1) = (-1,0,0), w_(n-2) = (1,0,0), and w_(n-3) = (x,y,0).
  ----------------
  J = sub(J,
    { w_(n-1,0) => -1, w_(n-1,1) => 0, w_(n-1,2) => 0,
      w_(n-2,0) => 1, w_(n-2,1) => 0, w_(n-2,2) => 0,
      w_(n-3,2) => 0 }
  );

  -------
  -- Change ring of ideal, removing last 7 variables.
  -------
  S = kk[Zvars, Wvars_{0.. ( 3*n-1 - 7 ) }, MonomialOrder => GRevLex];

  J = sub(J, S); -- map ideal J from ring R to ring S.

) else ( -- do not fix a dipole.
  ----------------
  -- Fix: w_{n-1} = (-1,0,0) and w_{n-2} = (x,y,0).
  --
  -- In this case we must also remove the possibility of w_(n-2) forming
  -- a dipole with w_(n-1), as this would generate an S^1 orthogonal symmetry.
  -- For this we add the condition w_(n-2,0) != 1, with an auxiliary variable t.
  ----------------

  -------
  -- Fix variables.
  -------
  J = sub(J,
    { w_(n-1,0) => -1, w_(n-1,1) => 0, w_(n-1,2) => 0,
      w_(n-2,2) => 0 }
  );

  -------
  -- Change ring of ideal, removing last 4 variables, and
  -- adding an auxiliary variable t.
  -------
  S = kk[Zvars, Wvars_{0..(3*n-1-4)}, t, MonomialOrder => GRevLex];

  J = sub(J, S); -- map ideal J from ring R to ring S.

  J = J + ideal( t * ( w_(n-2,0) - 1 ) - 1 ); -- w_(n-2,0) != 1, avoids dipole with w_(n-1).

);


--------------
-- Save ideal generators as a text file with msolve format.
--
-- The saved file will need post processing to remove underscores.
-- In VSCodium this can be done searching for the regex: _\((\d),(\d)\) and replacing it with $1$2.
--
-- Two other things need to be removed from the saved file (manually):
-- -- the parenthesis { and } that hold the variables of the first line, and
-- -- the comma after the last generator.
--------------
if saveIdeal then (
  load "../saveAsMsolve.m2"; -- load auxiliary function that does the saving

  ------
  -- Name of file, of the form: n4p0idealCartesian.ms
  ------
  if fixDipole then ( -- add Dipole to name
    fileName = concatenate( "n", toString(n), "p", toString(p), "idealCartesianDipole.ms" );
  ) else (
    fileName = concatenate( "n", toString(n), "p", toString(p), "idealCartesian.ms" );
  );

  saveAsMsolve(fileName, S, p, J);
);

